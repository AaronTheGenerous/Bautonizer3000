Index: bAUTOnizer3000_stable.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\nimport os\r\nimport json\r\nimport datetime\r\nfrom PyQt6 import QtCore\r\nfrom PyQt6.QtWidgets import (\r\n    QApplication,\r\n    QWidget,\r\n    QVBoxLayout,\r\n    QHBoxLayout,\r\n    QComboBox,\r\n    QLineEdit,\r\n    QPushButton,\r\n    QLabel,\r\n    QMessageBox,\r\n    QTabWidget,\r\n    QDialog,\r\n    QTimeEdit,\r\n    QCalendarWidget,\r\n    QRadioButton,\r\n    QButtonGroup,\r\n    QCheckBox,\r\n)\r\nfrom PyQt6.QtCore import Qt, QDate, QTime\r\nfrom PyQt6.QtGui import QIcon, QFont\r\n\r\n\r\nclass App(QWidget):\r\n    tasks_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"tasks\")\r\n    last_task_end_time_file = os.path.join(tasks_directory, \"last_task_end_time.json\")\r\n    multi_mode = False  # Track if multi-mode is enabled\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.title = \"Buttonizer3000\"\r\n        self.left = 100\r\n        self.top = 100\r\n        self.width = 230\r\n        self.height = 600  # Increased height to accommodate the switch and banner\r\n\r\n        self.selected_date = QDate.currentDate()\r\n        self.selected_time = QTime.currentTime()\r\n\r\n        self.temp_tasks = []  # Temporary storage for tasks in multi-task mode\r\n\r\n        self.button_layouts = {} #Temporary storage for each button layout\r\n\r\n        self.category_data = {\r\n            \"Kamerasysteme + Objektive\": {\r\n                \"Nikon\": {\r\n                    \"Nikon Z\": {},\r\n                    \"Nikkor Z-Mount Objektive\": {},\r\n                    \"Nikon DSLR\": {},\r\n                    \"Nikkor F-Mount Objektive\": {},\r\n                    \"Nikon Blitzgeräte\": {},\r\n                    \"Nikon Coolpix\": {},\r\n                    \"Nikon DSLR Zubehör\": {},\r\n                    \"Nikon Objektivzubehör\": {},\r\n                },\r\n                \"Sony\": {\r\n                    \"Sony E-Mount Kameras\": {},\r\n                    \"Sony E-Mount Objektive\": {},\r\n                    \"Sony E-Mount APS-C Kameras\": {},\r\n                    \"Sony E-Mount APS-C Objektive\": {},\r\n                    \"Sony E-Mount Zubehör\": {},\r\n                    \"Sony Blitzgeräte\": {},\r\n                    \"Sony Kompaktkameras\": {},\r\n                    \"Sony XPERIA Smartphones\": {},\r\n                    \"Sony A-Mount Kameras\": {},\r\n                    \"Sony A-Mount Objektive\": {},\r\n                    \"Sony A-Mount Zubehör\": {},\r\n                },\r\n                \"Phase One\": {\r\n                    \"Phase One IQ Backs\": {},\r\n                    \"Phase One XF Camera System\": {},\r\n                    \"Phase One XT Camera System\": {},\r\n                    \"CPO Phase One IQ Backs für Phase One XF\": {},\r\n                    \"CPO Phase One XF Kamerasysteme\": {},\r\n                    \"CPO Phase One IQ Backs für Hasselblad\": {},\r\n                    \"Phase One XF Kamerasysteme\": {},\r\n                    \"Phase One XT Kamera und Objektive\": {},\r\n                    \"Schneider Kreuznach Objektive (Blue Ring)\": {},\r\n                    \"CPO Schneider Kreuznach Objektive\": {},\r\n                    \"Capture One\": {},\r\n                },\r\n                \"Cambo\": {\r\n                    \"Cambo Wide RS\": {},\r\n                    \"Cambo ACTUS\": {},\r\n                    \"Cambo Zubehör zu Phase One XT\": {},\r\n                    \"Cambo Adapter\": {},\r\n                    \"Cambo ACTUS DB\": {},\r\n                    \"Cambo ACTUS-XL\": {},\r\n                },\r\n                \"Leica\": {\r\n                    \"Leica M & Objektive\": {},\r\n                    \"Leica Q\": {},\r\n                    \"Leica SL & Objektive\": {},\r\n                    \"Leica S & Objektive\": {},\r\n                    \"Leica TL / CL & Objektive\": {},\r\n                    \"Leica V\": {},\r\n                    \"Leica X\": {},\r\n                    \"Leica SOFORT\": {},\r\n                },\r\n            }\r\n        }\r\n\r\n        self.initUI()\r\n\r\n    def initUI(self):\r\n        self.setWindowTitle(self.title)\r\n        self.setGeometry(self.left, self.top, self.width, self.height)\r\n        self.setWindowIcon(QIcon(r\"C:\\path\\to\\icon.ico\"))\r\n\r\n        self.main_layout = QVBoxLayout()\r\n\r\n        # Create the switch for Single-Task Mode and Multi-Task Mode\r\n        self.create_mode_switch(self.main_layout)\r\n\r\n        self.banner_label = self.create_label(\"\", 10, Qt.AlignmentFlag.AlignCenter)\r\n        self.main_layout.addWidget(self.banner_label)\r\n\r\n        self.tab_widget = QTabWidget()\r\n        self.tab_widget.setStyleSheet(\"QTabWidget::pane { border: 2px solid #ffffff; }\")\r\n        self.tab_widget.addTab(\r\n            self.create_tab(\"Hinzufügen\", self.schedule_task), \"Hinzufügen\"\r\n        )\r\n        self.tab_widget.addTab(\r\n            self.create_tab(\"Entfernen\", self.schedule_task), \"Entfernen\"\r\n        )\r\n        self.main_layout.addWidget(self.tab_widget)\r\n\r\n        self.display_label_title = self.create_label(\r\n            \"<b>Geplantes Datum und Uhrzeit</b>\", 10, Qt.AlignmentFlag.AlignCenter, True\r\n        )\r\n        self.main_layout.addWidget(self.display_label_title)\r\n\r\n        self.datetime_label = self.create_label(\r\n            \"\", 15, Qt.AlignmentFlag.AlignCenter, True\r\n        )\r\n        self.update_datetime_label()\r\n        self.main_layout.addWidget(self.datetime_label)\r\n\r\n        self.setLayout(self.main_layout)\r\n        self.center_on_screen()\r\n        self.show()\r\n\r\n    def create_mode_switch(self, layout):\r\n        self.single_task_radio = QRadioButton(\"Single-Task Mode\")\r\n        self.multi_task_radio = QRadioButton(\"Multi-Task Mode\")\r\n\r\n        self.button_group = QButtonGroup(self)\r\n        self.button_group.addButton(self.single_task_radio)\r\n        self.button_group.addButton(self.multi_task_radio)\r\n        self.single_task_radio.setChecked(True)  # Default to Single-Task Mode\r\n\r\n        self.single_task_radio.toggled.connect(self.toggle_multi_mode)\r\n        self.multi_task_radio.toggled.connect(self.toggle_multi_mode)\r\n\r\n        switch_layout = QHBoxLayout()\r\n        switch_layout.addWidget(self.single_task_radio)\r\n        switch_layout.addWidget(self.multi_task_radio)\r\n        layout.addLayout(switch_layout)\r\n\r\n    def toggle_multi_mode(self):\r\n        self.multi_mode = self.multi_task_radio.isChecked()\r\n        self.tab_widget.setStyleSheet(\r\n            \"QTabWidget::pane { border: 2px solid #ffdd00; }\"\r\n            if self.multi_mode\r\n            else \"QTabWidget::pane { border: 2px solid #ffffff; }\"\r\n        )\r\n        self.banner_label.setText(\r\n            \"<b>Multi-Task Mode</b>\" + \"<br>\" + \"Startzeit und Datum Wählen\"\r\n            if self.multi_mode\r\n            else \"\"\r\n        )\r\n\r\n        for tab_name in self.button_layouts:\r\n            self.update_buttons(tab_name)\r\n        self.update_ui_elements()\r\n\r\n    def update_buttons(self, tab_name):\r\n        button_layout = self.button_layouts[tab_name]\r\n        self.clear_layout(button_layout)\r\n        if self.multi_mode:\r\n            next_task_button = self.create_button(\r\n                \"Next Task\", self.save_task_temporarily\r\n            )\r\n            plan_tasks_button = self.create_button(\"Tasks Planen\", self.save_all_tasks)\r\n            button_layout.addWidget(next_task_button)\r\n            button_layout.addWidget(plan_tasks_button)\r\n        else:\r\n            submit_button = self.create_button(\r\n                \"Bestätigen\",\r\n                lambda: self.schedule_task(\r\n                    self.marken_combobox,\r\n                    self.categories_combobox,\r\n                    self.articles_input,\r\n                    tab_name,\r\n                ),\r\n            )\r\n            button_layout.addWidget(submit_button)\r\n\r\n    def clear_layout(self, layout):\r\n        while layout.count():\r\n            child = layout.takeAt(0)\r\n            if child.widget():\r\n                child.widget().deleteLater()\r\n\r\n    def create_tab(self, tab_name, submit_action):\r\n        tab = QWidget()\r\n        layout = QVBoxLayout()\r\n\r\n        self.current_tab_name = tab_name\r\n        marken_label, marken_combobox = self.create_label_and_combobox(\r\n            \"Marke\", self.category_data[\"Kamerasysteme + Objektive\"].keys()\r\n        )\r\n        layout.addWidget(marken_label)\r\n        layout.addWidget(marken_combobox)\r\n        self.marken_combobox = marken_combobox\r\n\r\n        categories_label, categories_combobox = self.create_label_and_combobox(\r\n            \"Kategorie\", []\r\n        )\r\n        layout.addWidget(categories_label)\r\n        layout.addWidget(categories_combobox)\r\n        self.categories_combobox = categories_combobox\r\n\r\n        layout.addStretch()\r\n        articles_input = self.create_line_edit_with_label(\r\n            \"Artikelnummern (getrennt mit Kommas)\", layout\r\n        )\r\n        layout.addWidget(articles_input)\r\n        self.articles_input = articles_input\r\n\r\n        if tab_name == \"Hinzufügen\":\r\n            self.add_image_and_link_fields(layout)\r\n\r\n        self.add_datetime_fields(layout)\r\n\r\n        button_layout = QVBoxLayout()\r\n        self.button_layouts[tab_name] = button_layout  # Store the button layout\r\n        self.update_buttons(tab_name)\r\n        layout.addLayout(button_layout)\r\n\r\n        self.update_subcategories(marken_combobox, categories_combobox)\r\n        marken_combobox.currentTextChanged.connect(\r\n            lambda: self.update_subcategories(marken_combobox, categories_combobox)\r\n        )\r\n\r\n        tab.setLayout(layout)\r\n\r\n        return tab\r\n\r\n    def create_label_and_combobox(self, label_text, items):\r\n        label = QLabel(label_text, self)\r\n        combobox = QComboBox(self)\r\n        combobox.addItems(items)\r\n        return label, combobox\r\n\r\n    def create_line_edit_with_label(self, label_text, layout):\r\n        label = QLabel(label_text, self)\r\n        layout.addWidget(label)\r\n        return QLineEdit(self)\r\n\r\n    def create_label(self, text, font_size, alignment, with_border=False):\r\n        label = QLabel(text, self)\r\n        font = QFont()\r\n        font.setPointSize(font_size)\r\n        label.setFont(font)\r\n        label.setAlignment(alignment)\r\n        if with_border:\r\n            label.setStyleSheet(\"border: 2px solid #ffdd00;\")\r\n        return label\r\n\r\n    def create_button(self, text, click_handler):\r\n        button = QPushButton(text, self)\r\n        button.clicked.connect(click_handler)\r\n        return button\r\n\r\n    def add_image_and_link_fields(self, layout):\r\n        fields = [\r\n            (\"Bild 1 URL (Deutsch)\", \"img1_input\"),\r\n            (\"Bild 2 URL (Französisch)\", \"img2_input\"),\r\n            (\"Bild Höhe\", \"height_input\"),\r\n            (\"Bildbreite\", \"width_input\"),\r\n        ]\r\n        for label_text, attr_name in fields:\r\n            setattr(\r\n                self, attr_name, self.create_line_edit_with_label(label_text, layout)\r\n            )\r\n            layout.addWidget(getattr(self, attr_name))\r\n\r\n        self.link_checkbox = QCheckBox(\"Link hinzufügen?\", self)\r\n        layout.addWidget(self.link_checkbox)\r\n\r\n        self.link_input_de = self.create_line_edit_with_label(\"Link (Deutsch)\", layout)\r\n        self.link_input_de.setDisabled(True)\r\n        layout.addWidget(self.link_input_de)\r\n\r\n        self.link_input_fr = self.create_line_edit_with_label(\r\n            \"Link (Französisch)\", layout\r\n        )\r\n        self.link_input_fr.setDisabled(True)\r\n        layout.addWidget(self.link_input_fr)\r\n\r\n        self.link_checkbox.stateChanged.connect(\r\n            lambda state: self.toggle_link_input(\r\n                state, self.link_input_de, self.link_input_fr\r\n            )\r\n        )\r\n\r\n    def add_datetime_fields(self, layout):\r\n        self.dateTime_title_label = QLabel(\"<b>Datum & Uhrzeit planen</b>\", self)\r\n        self.dateTime_title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\r\n        self.dateTime_title_label.setStyleSheet(\r\n            \"\"\"\r\n            QLabel{\r\n                font-weight: bold;\r\n            }\r\n        \"\"\"\r\n        )\r\n        layout.addWidget(self.dateTime_title_label)\r\n\r\n        buttons = [\r\n            (\"Datum wählen\", self.open_date_picker),\r\n            (\"Uhrzeit wählen\", self.open_time_picker),\r\n        ]\r\n        self.datetime_buttons = []\r\n        for text, handler in buttons:\r\n            button = QPushButton(text, self)\r\n            button.clicked.connect(handler)\r\n            layout.addWidget(button)\r\n            self.datetime_buttons.append(button)\r\n\r\n    def open_date_picker(self):\r\n        dialog = DatePickerDialog(self)\r\n        if dialog.exec():\r\n            self.selected_date = dialog.get_date()\r\n            self.update_datetime_label()\r\n\r\n    def open_time_picker(self):\r\n        dialog = TimePickerDialog(self)\r\n        if dialog.exec():\r\n            self.selected_time = dialog.get_time()\r\n            self.update_datetime_label()\r\n\r\n    def update_datetime_label(self):\r\n        selected_date = self.selected_date.toString(\"dd/MM/yyyy\")\r\n        selected_time = self.selected_time.toString(\"HH:mm:ss\")\r\n        self.datetime_label.setText(f\"{selected_date} \\n{selected_time}\")\r\n\r\n    def show_message(self):\r\n        msg_box = QMessageBox(self)\r\n        msg_box.setWindowTitle(\"Geschafft\")\r\n        msg_box.setText(\r\n            \"Task erfolgreich geplant. \\nDu siehst heute übrigens mal wieder super aus <3\"\r\n        )\r\n        msg_box.setIcon(QMessageBox.Icon.Information)\r\n        msg_box.exec()\r\n\r\n    def eventFilter(self, obj, event):\r\n        if event.type() == QtCore.QEvent.Type.KeyPress and event.key() in [\r\n            Qt.Key.Key_Enter,\r\n            Qt.Key.Key_Return,\r\n        ]:\r\n            current_tab_index = self.tab_widget.currentIndex()\r\n            if current_tab_index == 0:\r\n                self.submit_button.click()\r\n            elif current_tab_index == 1:\r\n                self.submit_button2.click()\r\n            return True\r\n        return super().eventFilter(obj, event)\r\n\r\n    def save_task_temporarily(self):\r\n        task = self.create_task()\r\n        self.temp_tasks.append(task)\r\n        self.clear_input_fields()\r\n        if len(self.temp_tasks) == 1:\r\n            self.banner_label.setText(\r\n                \"<b>Multi-Task Mode</b>\" + \"<br>\" + \"Nach dem ersten Task ausführen\"\r\n            )\r\n            self.hide_datetime_fields()\r\n\r\n    def save_all_tasks(self):\r\n        task_directory = self.tasks_directory\r\n        os.makedirs(task_directory, exist_ok=True)\r\n\r\n        initial_task = self.temp_tasks[0]\r\n        initial_task[\"subsequent_tasks\"] = []\r\n\r\n        for idx, task in enumerate(self.temp_tasks):\r\n            task_filename = os.path.join(\r\n                task_directory,\r\n                f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}_{idx}.json',\r\n            )\r\n            with open(task_filename, \"w\") as file:\r\n                json.dump(task, file)\r\n            if idx > 0:\r\n                initial_task[\"subsequent_tasks\"].append(task_filename)\r\n\r\n        # Save the initial task with its subsequent tasks\r\n        initial_task_filename = os.path.join(\r\n            task_directory,\r\n            f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}_0.json',\r\n        )\r\n        with open(initial_task_filename, \"w\") as file:\r\n            json.dump(initial_task, file)\r\n\r\n        QMessageBox.information(\r\n            self, \"Success\", \"All tasks have been scheduled successfully!\"\r\n        )\r\n\r\n    def create_task(self):\r\n        task_type = (\r\n            \"process_articles\"\r\n            if self.current_tab_name == \"Hinzufügen\"\r\n            else \"remove_articles_images\"\r\n        )\r\n\r\n        task = {\r\n            \"task_type\": task_type,\r\n            \"schedule_datetime\": self.get_scheduled_time().isoformat(),\r\n            \"data\": {\r\n                \"marke\": self.marken_combobox.currentText(),\r\n                \"kategorie\": self.categories_combobox.currentText(),\r\n                \"article_numbers\": self.articles_input.text(),\r\n                \"img1_url\": (\r\n                    self.img1_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"img2_url\": (\r\n                    self.img2_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"width\": (\r\n                    self.width_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"height\": (\r\n                    self.height_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_checkbox\": (\r\n                    self.link_checkbox.isChecked()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_input_de\": (\r\n                    self.link_input_de.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_input_fr\": (\r\n                    self.link_input_fr.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n            },\r\n            \"follow_up\": self.multi_mode,\r\n        }\r\n        return task\r\n\r\n    def clear_input_fields(self):\r\n        self.marken_combobox.setCurrentIndex(0)\r\n        self.categories_combobox.setCurrentIndex(0)\r\n        self.articles_input.clear()\r\n        if self.current_tab_name == \"Hinzufügen\":\r\n            self.img1_input.clear()\r\n            self.img2_input.clear()\r\n            self.width_input.clear()\r\n            self.height_input.clear()\r\n            self.link_checkbox.setChecked(False)\r\n            self.link_input_de.clear()\r\n            self.link_input_fr.clear()\r\n\r\n    def hide_datetime_fields(self):\r\n        self.dateTime_title_label.hide()\r\n        for button in self.datetime_buttons:\r\n            button.hide()\r\n        self.display_label_title.hide()\r\n        self.datetime_label.hide()\r\n\r\n    def show_datetime_fields(self):\r\n        self.dateTime_title_label.show()\r\n        for button in self.datetime_buttons:\r\n            button.show()\r\n        self.display_label_title.show()\r\n        self.datetime_label.show()\r\n\r\n    def get_scheduled_time(self):\r\n        return datetime.datetime(\r\n            self.selected_date.year(),\r\n            self.selected_date.month(),\r\n            self.selected_date.day(),\r\n            self.selected_time.hour(),\r\n            self.selected_time.minute(),\r\n            self.selected_time.second(),\r\n        )\r\n\r\n    def schedule_task(self, marken_box, categories_box, articles_input, tab_name):\r\n        task = self.create_task()\r\n\r\n        task_filename = os.path.join(\r\n            self.tasks_directory,\r\n            f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}.json',\r\n        )\r\n\r\n        os.makedirs(self.tasks_directory, exist_ok=True)\r\n\r\n        with open(task_filename, \"w\") as file:\r\n            json.dump(task, file)\r\n\r\n        if not self.multi_mode:\r\n            # Convert schedule_datetime from string to datetime object\r\n            schedule_datetime = datetime.datetime.fromisoformat(\r\n                task[\"schedule_datetime\"]\r\n            )\r\n            self.schedule_in_task_scheduler(task_filename, schedule_datetime)\r\n\r\n        QMessageBox.information(self, \"Success\", \"Task scheduled successfully!\")\r\n\r\n    def schedule_in_task_scheduler(self, task_filename, schedule_datetime):\r\n        import subprocess\r\n\r\n        date_str = schedule_datetime.strftime(\"%d/%m/%Y\")\r\n        time_str = schedule_datetime.strftime(\"%H:%M\")\r\n        command = f'SchTasks /Create /SC ONCE /TN \"ButtonizerTask_{os.path.basename(task_filename)}\" /TR \"python {os.path.abspath(__file__).replace(\"bAUTOnizer3000.py\", \"exe_tasks.py\")} {task_filename}\" /ST {time_str} /SD {date_str} /F'\r\n        try:\r\n            subprocess.run(command, check=True, shell=True)\r\n        except subprocess.CalledProcessError as e:\r\n            print(f\"Failed to schedule task: {e}\")\r\n\r\n    def toggle_link_input(self, state, link_input_de, link_input_fr):\r\n        is_enabled = state == Qt.CheckState.Checked\r\n        link_input_de.setDisabled(not is_enabled)\r\n        link_input_fr.setDisabled(not is_enabled)\r\n\r\n    def center_on_screen(self):\r\n        qr = self.frameGeometry()\r\n        screen_geometry = QApplication.primaryScreen().availableGeometry()\r\n        cp = screen_geometry.center()\r\n        cp.setX(int(screen_geometry.width() * 3 / 4 - qr.width() / 4))\r\n        qr.moveCenter(cp)\r\n        self.move(qr.topLeft())\r\n\r\n    def update_subcategories(self, marken_box, categories_box):\r\n        current_brand = marken_box.currentText()\r\n        categories_box.clear()\r\n        if current_brand in self.category_data[\"Kamerasysteme + Objektive\"]:\r\n            categories_box.addItems(\r\n                self.category_data[\"Kamerasysteme + Objektive\"][current_brand].keys()\r\n            )\r\n            categories_box.setCurrentIndex(0)\r\n            categories_box.setDisabled(False)\r\n        else:\r\n            categories_box.addItem(\"Keine Kategorien verfügbar\")\r\n            categories_box.setDisabled(True)\r\n\r\n    def update_ui_elements(self):\r\n        if self.multi_mode and len(self.temp_tasks) == 0:\r\n            self.show_datetime_fields()\r\n        elif self.multi_mode and len(self.temp_tasks) > 0:\r\n            self.hide_datetime_fields()\r\n        else:\r\n            self.show_datetime_fields()\r\n\r\n    def debug_temporary_tasks(self):\r\n        print(\"Temporary tasks stored:\")\r\n        for idx, task in enumerate(self.temp_tasks):\r\n            print(f\"Task {idx + 1}: {task}\")\r\n\r\n\r\nclass TimePickerDialog(QDialog):\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n        self.setWindowTitle(\"Select Time\")\r\n        self.layout = QVBoxLayout()\r\n        self.time_edit = QTimeEdit(self)\r\n        self.time_edit.setDisplayFormat(\"HH:mm:ss\")\r\n        self.time_edit.setTime(QtCore.QTime.currentTime())\r\n        self.layout.addWidget(self.time_edit)\r\n\r\n        self.ok_button = QPushButton(\"OK\", self)\r\n        self.ok_button.clicked.connect(self.confirm_time)\r\n        self.layout.addWidget(self.ok_button)\r\n\r\n        self.setLayout(self.layout)\r\n\r\n    def confirm_time(self):\r\n        self.selected_time = self.time_edit.time()\r\n        self.accept()\r\n\r\n    def get_time(self):\r\n        return self.selected_time\r\n\r\n\r\nclass DatePickerDialog(QDialog):\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n        self.setWindowTitle(\"Select Date\")\r\n        self.layout = QVBoxLayout()\r\n\r\n        self.calendar_widget = QCalendarWidget()\r\n        self.layout.addWidget(self.calendar_widget)\r\n\r\n        confirm_button = QPushButton(\"OK\")\r\n        confirm_button.clicked.connect(self.confirm_date)\r\n        self.layout.addWidget(confirm_button)\r\n\r\n        self.selected_date = QDate.currentDate()\r\n\r\n        self.setLayout(self.layout)\r\n\r\n    def confirm_date(self):\r\n        self.selected_date = self.calendar_widget.selectedDate()\r\n        self.accept()\r\n\r\n    def get_date(self):\r\n        return self.selected_date\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app = QApplication(sys.argv)\r\n    ex = App()\r\n    sys.exit(app.exec())\r\n
===================================================================
diff --git a/bAUTOnizer3000_stable.py b/bAUTOnizer3000_stable.py
--- a/bAUTOnizer3000_stable.py	
+++ b/bAUTOnizer3000_stable.py	
@@ -21,8 +21,61 @@
     QButtonGroup,
     QCheckBox,
 )
-from PyQt6.QtCore import Qt, QDate, QTime
-from PyQt6.QtGui import QIcon, QFont
+from PyQt6.QtCore import Qt, QDate, QTime, QEasingCurve, QPropertyAnimation
+from PyQt6.QtGui import QIcon, QFont, QColor, QPainter, QPen
+
+
+class DatePickerDialog(QDialog):
+    def __init__(self, parent=None):
+        super().__init__(parent)
+        self.layout = None
+        self.calendar = None
+        self.setWindowTitle("Datum wählen")
+        self.create_calendar_widget()
+        self.create_buttons()
+
+    def create_calendar_widget(self):
+        self.calendar = QCalendarWidget(self)
+        self.calendar.setGridVisible(True)
+        self.layout = QVBoxLayout(self)
+        self.layout.addWidget(self.calendar)
+
+    def create_buttons(self):
+        buttons = QHBoxLayout()
+        ok_button = self.create_button("OK", self.accept)
+        cancel_button = self.create_button("Abbrechen", self.reject)
+        buttons.addWidget(ok_button)
+        buttons.addWidget(cancel_button)
+        self.layout.addLayout(buttons)
+
+    def create_button(self, text, handler):
+        button = QPushButton(text, self)
+        button.clicked.connect(handler)
+        return button
+
+    def get_date(self):
+        return self.calendar.selectedDate()
+
+
+class TimePickerDialog(QDialog):
+    def __init__(self, parent=None):
+        super().__init__(parent)
+        self.setWindowTitle("Uhrzeit wählen")
+        self.time_edit = QTimeEdit(self)
+        self.time_edit.setDisplayFormat("HH:mm:ss")
+        layout = QVBoxLayout(self)
+        layout.addWidget(self.time_edit)
+        buttons = QHBoxLayout()
+        ok_button = QPushButton("OK", self)
+        ok_button.clicked.connect(self.accept)
+        cancel_button = QPushButton("Cancel", self)
+        cancel_button.clicked.connect(self.reject)
+        buttons.addWidget(ok_button)
+        buttons.addWidget(cancel_button)
+        layout.addLayout(buttons)
+
+    def get_time(self):
+        return self.time_edit.time()
 
 
 class App(QWidget):
@@ -35,15 +88,16 @@
         self.title = "Buttonizer3000"
         self.left = 100
         self.top = 100
-        self.width = 230
-        self.height = 600  # Increased height to accommodate the switch and banner
+        self.window_width = 260
+        self.height = 850  # Increased height to accommodate the switch and banner
+        self.borderColor = QColor(255, 221, 0, 0)  # Initial border color (transparent yellow)
 
         self.selected_date = QDate.currentDate()
         self.selected_time = QTime.currentTime()
 
         self.temp_tasks = []  # Temporary storage for tasks in multi-task mode
 
-        self.button_layouts = {} #Temporary storage for each button layout
+        self.button_layouts = {}  # Temporary storage for each button layout
 
         self.category_data = {
             "Kamerasysteme + Objektive": {
@@ -108,7 +162,8 @@
 
     def initUI(self):
         self.setWindowTitle(self.title)
-        self.setGeometry(self.left, self.top, self.width, self.height)
+        self.setGeometry(self.left, self.top, self.window_width, self.height)
+        self.setFixedSize(self.window_width, self.height)
         self.setWindowIcon(QIcon(r"C:\path\to\icon.ico"))
 
         self.main_layout = QVBoxLayout()
@@ -116,6 +171,10 @@
         # Create the switch for Single-Task Mode and Multi-Task Mode
         self.create_mode_switch(self.main_layout)
 
+        # New banner label at the very top
+        self.top_banner_label = self.create_label("", 10, Qt.AlignmentFlag.AlignCenter)
+        self.main_layout.addWidget(self.top_banner_label)
+
         self.banner_label = self.create_label("", 10, Qt.AlignmentFlag.AlignCenter)
         self.main_layout.addWidget(self.banner_label)
 
@@ -144,6 +203,114 @@
         self.center_on_screen()
         self.show()
 
+    def add_datetime_fields(self, layout):
+        self.dateTime_title_label = QLabel("<b>Datum & Uhrzeit planen</b>", self)
+        self.dateTime_title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
+        self.dateTime_title_label.setStyleSheet(
+            """
+            QLabel{
+                font-weight: bold;
+            }
+        """
+        )
+        layout.addWidget(self.dateTime_title_label)
+
+        buttons = [
+            ("Datum wählen", self.open_date_picker),
+            ("Uhrzeit wählen", self.open_time_picker),
+        ]
+        self.datetime_buttons = []
+        for text, handler in buttons:
+            button = QPushButton(text, self)
+            button.clicked.connect(handler)
+            self.datetime_buttons.append(button)
+
+        for button in self.datetime_buttons:
+            layout.addWidget(button)
+
+    def add_image_and_link_fields(self, layout):
+        fields = [
+            ("Bild 1 URL (Deutsch)", "img1_input"),
+            ("Bild 2 URL (Französisch)", "img2_input"),
+            ("Bild Höhe", "height_input"),
+            ("Bildbreite", "width_input"),
+        ]
+        for label_text, attr_name in fields:
+            setattr(
+                self, attr_name, self.create_line_edit_with_label(label_text, layout)
+            )
+            layout.addWidget(getattr(self, attr_name))
+
+        self.link_checkbox = QCheckBox("Link hinzufügen?", self)
+        layout.addWidget(self.link_checkbox)
+
+        self.link_input_de = self.create_line_edit_with_label("Link (Deutsch)", layout)
+        self.link_input_de.setDisabled(True)
+        layout.addWidget(self.link_input_de)
+
+        self.link_input_fr = self.create_line_edit_with_label(
+            "Link (Französisch)", layout
+        )
+        self.link_input_fr.setDisabled(True)
+        layout.addWidget(self.link_input_fr)
+
+        self.link_checkbox.stateChanged.connect(
+            lambda state: self.toggle_link_input(
+                state, self.link_input_de, self.link_input_fr
+            )
+        )
+
+    def center_on_screen(self):
+        resolution = QApplication.primaryScreen().geometry()
+        x = (resolution.width() - self.window_width) // 2
+        y = (resolution.height() - self.height) // 2
+        self.move(x, y)
+
+    def clear_input_fields(self):
+        self.marken_combobox.setCurrentIndex(0)
+        self.categories_combobox.setCurrentIndex(0)
+        self.articles_input.clear()
+        if self.current_tab_name == "Hinzufügen":
+            self.img1_input.clear()
+            self.img2_input.clear()
+            self.width_input.clear()
+            self.height_input.clear()
+            self.link_checkbox.setChecked(False)
+            self.link_input_de.clear()
+            self.link_input_fr.clear()
+
+    def clear_layout(self, layout):
+        while layout.count():
+            child = layout.takeAt(0)
+            if child.widget():
+                child.widget().deleteLater()
+
+    def create_button(self, text, click_handler):
+        button = QPushButton(text, self)
+        button.clicked.connect(click_handler)
+        return button
+
+    def create_label(self, text, font_size, alignment, with_border=False):
+        label = QLabel(text, self)
+        font = QFont()
+        font.setPointSize(font_size)
+        label.setFont(font)
+        label.setAlignment(alignment)
+        if with_border:
+            label.setStyleSheet("border: 2px solid #ffdd00;")
+        return label
+
+    def create_label_and_combobox(self, label_text, items):
+        label = QLabel(label_text, self)
+        combobox = QComboBox(self)
+        combobox.addItems(items)
+        return label, combobox
+
+    def create_line_edit_with_label(self, label_text, layout):
+        label = QLabel(label_text, self)
+        layout.addWidget(label)
+        return QLineEdit(self)
+
     def create_mode_switch(self, layout):
         self.single_task_radio = QRadioButton("Single-Task Mode")
         self.multi_task_radio = QRadioButton("Multi-Task Mode")
@@ -161,51 +328,6 @@
         switch_layout.addWidget(self.multi_task_radio)
         layout.addLayout(switch_layout)
 
-    def toggle_multi_mode(self):
-        self.multi_mode = self.multi_task_radio.isChecked()
-        self.tab_widget.setStyleSheet(
-            "QTabWidget::pane { border: 2px solid #ffdd00; }"
-            if self.multi_mode
-            else "QTabWidget::pane { border: 2px solid #ffffff; }"
-        )
-        self.banner_label.setText(
-            "<b>Multi-Task Mode</b>" + "<br>" + "Startzeit und Datum Wählen"
-            if self.multi_mode
-            else ""
-        )
-
-        for tab_name in self.button_layouts:
-            self.update_buttons(tab_name)
-        self.update_ui_elements()
-
-    def update_buttons(self, tab_name):
-        button_layout = self.button_layouts[tab_name]
-        self.clear_layout(button_layout)
-        if self.multi_mode:
-            next_task_button = self.create_button(
-                "Next Task", self.save_task_temporarily
-            )
-            plan_tasks_button = self.create_button("Tasks Planen", self.save_all_tasks)
-            button_layout.addWidget(next_task_button)
-            button_layout.addWidget(plan_tasks_button)
-        else:
-            submit_button = self.create_button(
-                "Bestätigen",
-                lambda: self.schedule_task(
-                    self.marken_combobox,
-                    self.categories_combobox,
-                    self.articles_input,
-                    tab_name,
-                ),
-            )
-            button_layout.addWidget(submit_button)
-
-    def clear_layout(self, layout):
-        while layout.count():
-            child = layout.takeAt(0)
-            if child.widget():
-                child.widget().deleteLater()
-
     def create_tab(self, tab_name, submit_action):
         tab = QWidget()
         layout = QVBoxLayout()
@@ -251,166 +373,8 @@
 
         return tab
 
-    def create_label_and_combobox(self, label_text, items):
-        label = QLabel(label_text, self)
-        combobox = QComboBox(self)
-        combobox.addItems(items)
-        return label, combobox
-
-    def create_line_edit_with_label(self, label_text, layout):
-        label = QLabel(label_text, self)
-        layout.addWidget(label)
-        return QLineEdit(self)
-
-    def create_label(self, text, font_size, alignment, with_border=False):
-        label = QLabel(text, self)
-        font = QFont()
-        font.setPointSize(font_size)
-        label.setFont(font)
-        label.setAlignment(alignment)
-        if with_border:
-            label.setStyleSheet("border: 2px solid #ffdd00;")
-        return label
-
-    def create_button(self, text, click_handler):
-        button = QPushButton(text, self)
-        button.clicked.connect(click_handler)
-        return button
-
-    def add_image_and_link_fields(self, layout):
-        fields = [
-            ("Bild 1 URL (Deutsch)", "img1_input"),
-            ("Bild 2 URL (Französisch)", "img2_input"),
-            ("Bild Höhe", "height_input"),
-            ("Bildbreite", "width_input"),
-        ]
-        for label_text, attr_name in fields:
-            setattr(
-                self, attr_name, self.create_line_edit_with_label(label_text, layout)
-            )
-            layout.addWidget(getattr(self, attr_name))
-
-        self.link_checkbox = QCheckBox("Link hinzufügen?", self)
-        layout.addWidget(self.link_checkbox)
-
-        self.link_input_de = self.create_line_edit_with_label("Link (Deutsch)", layout)
-        self.link_input_de.setDisabled(True)
-        layout.addWidget(self.link_input_de)
-
-        self.link_input_fr = self.create_line_edit_with_label(
-            "Link (Französisch)", layout
-        )
-        self.link_input_fr.setDisabled(True)
-        layout.addWidget(self.link_input_fr)
-
-        self.link_checkbox.stateChanged.connect(
-            lambda state: self.toggle_link_input(
-                state, self.link_input_de, self.link_input_fr
-            )
-        )
-
-    def add_datetime_fields(self, layout):
-        self.dateTime_title_label = QLabel("<b>Datum & Uhrzeit planen</b>", self)
-        self.dateTime_title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
-        self.dateTime_title_label.setStyleSheet(
-            """
-            QLabel{
-                font-weight: bold;
-            }
-        """
-        )
-        layout.addWidget(self.dateTime_title_label)
-
-        buttons = [
-            ("Datum wählen", self.open_date_picker),
-            ("Uhrzeit wählen", self.open_time_picker),
-        ]
-        self.datetime_buttons = []
-        for text, handler in buttons:
-            button = QPushButton(text, self)
-            button.clicked.connect(handler)
-            layout.addWidget(button)
-            self.datetime_buttons.append(button)
-
-    def open_date_picker(self):
-        dialog = DatePickerDialog(self)
-        if dialog.exec():
-            self.selected_date = dialog.get_date()
-            self.update_datetime_label()
-
-    def open_time_picker(self):
-        dialog = TimePickerDialog(self)
-        if dialog.exec():
-            self.selected_time = dialog.get_time()
-            self.update_datetime_label()
-
-    def update_datetime_label(self):
-        selected_date = self.selected_date.toString("dd/MM/yyyy")
-        selected_time = self.selected_time.toString("HH:mm:ss")
-        self.datetime_label.setText(f"{selected_date} \n{selected_time}")
-
-    def show_message(self):
-        msg_box = QMessageBox(self)
-        msg_box.setWindowTitle("Geschafft")
-        msg_box.setText(
-            "Task erfolgreich geplant. \nDu siehst heute übrigens mal wieder super aus <3"
-        )
-        msg_box.setIcon(QMessageBox.Icon.Information)
-        msg_box.exec()
-
-    def eventFilter(self, obj, event):
-        if event.type() == QtCore.QEvent.Type.KeyPress and event.key() in [
-            Qt.Key.Key_Enter,
-            Qt.Key.Key_Return,
-        ]:
-            current_tab_index = self.tab_widget.currentIndex()
-            if current_tab_index == 0:
-                self.submit_button.click()
-            elif current_tab_index == 1:
-                self.submit_button2.click()
-            return True
-        return super().eventFilter(obj, event)
-
-    def save_task_temporarily(self):
-        task = self.create_task()
-        self.temp_tasks.append(task)
-        self.clear_input_fields()
-        if len(self.temp_tasks) == 1:
-            self.banner_label.setText(
-                "<b>Multi-Task Mode</b>" + "<br>" + "Nach dem ersten Task ausführen"
-            )
-            self.hide_datetime_fields()
-
-    def save_all_tasks(self):
-        task_directory = self.tasks_directory
-        os.makedirs(task_directory, exist_ok=True)
-
-        initial_task = self.temp_tasks[0]
-        initial_task["subsequent_tasks"] = []
-
-        for idx, task in enumerate(self.temp_tasks):
-            task_filename = os.path.join(
-                task_directory,
-                f'task_{datetime.datetime.now().strftime("%Y%m%d%H%M%S")}_{idx}.json',
-            )
-            with open(task_filename, "w") as file:
-                json.dump(task, file)
-            if idx > 0:
-                initial_task["subsequent_tasks"].append(task_filename)
-
-        # Save the initial task with its subsequent tasks
-        initial_task_filename = os.path.join(
-            task_directory,
-            f'task_{datetime.datetime.now().strftime("%Y%m%d%H%M%S")}_0.json',
-        )
-        with open(initial_task_filename, "w") as file:
-            json.dump(initial_task, file)
-
-        QMessageBox.information(
-            self, "Success", "All tasks have been scheduled successfully!"
-        )
-
     def create_task(self):
+        print("create_task called")
         task_type = (
             "process_articles"
             if self.current_tab_name == "Hinzufügen"
@@ -464,42 +428,97 @@
         }
         return task
 
-    def clear_input_fields(self):
-        self.marken_combobox.setCurrentIndex(0)
-        self.categories_combobox.setCurrentIndex(0)
-        self.articles_input.clear()
-        if self.current_tab_name == "Hinzufügen":
-            self.img1_input.clear()
-            self.img2_input.clear()
-            self.width_input.clear()
-            self.height_input.clear()
-            self.link_checkbox.setChecked(False)
-            self.link_input_de.clear()
-            self.link_input_fr.clear()
+    def eventFilter(self, obj, event):
+        if event.type() == QtCore.QEvent.Type.KeyPress and event.key() in [
+            Qt.Key.Key_Enter,
+            Qt.Key.Key_Return,
+        ]:
+            current_tab_index = self.tab_widget.currentIndex()
+            if current_tab_index == 0:
+                self.submit_button.click()
+            elif current_tab_index == 1:
+                self.submit_button2.click()
+            return True
+        return super().eventFilter(obj, event)
 
     def hide_datetime_fields(self):
-        self.dateTime_title_label.hide()
-        for button in self.datetime_buttons:
-            button.hide()
         self.display_label_title.hide()
         self.datetime_label.hide()
-
-    def show_datetime_fields(self):
-        self.dateTime_title_label.show()
         for button in self.datetime_buttons:
-            button.show()
-        self.display_label_title.show()
-        self.datetime_label.show()
+            if button in self.layout.children():
+                self.layout.removeWidget(button)
+                button.hide()
+
+    def open_date_picker(self):
+        dialog = DatePickerDialog(self)
+        if dialog.exec():
+            self.selected_date = dialog.get_date()
+            self.update_datetime_label()
+
+    def open_time_picker(self):
+        dialog = TimePickerDialog(self)
+        if dialog.exec():
+            self.selected_time = dialog.get_time()
+            self.update_datetime_label()
+
+    def save_all_tasks(self):
+        task_directory = self.tasks_directory
+        os.makedirs(task_directory, exist_ok=True)
 
-    def get_scheduled_time(self):
-        return datetime.datetime(
-            self.selected_date.year(),
-            self.selected_date.month(),
-            self.selected_date.day(),
-            self.selected_time.hour(),
-            self.selected_time.minute(),
-            self.selected_time.second(),
+        initial_task = self.temp_tasks[0]
+        initial_task["subsequent_tasks"] = []
+
+        for idx, task in enumerate(self.temp_tasks):
+            task_filename = os.path.join(
+                task_directory,
+                f'task_{datetime.datetime.now().strftime("%Y%m%d%H%M%S")}_{idx}.json',
+            )
+            with open(task_filename, "w") as file:
+                json.dump(task, file)
+            if idx > 0:
+                initial_task["subsequent_tasks"].append(task_filename)
+
+        initial_task_filename = os.path.join(
+            task_directory,
+            f'task_{datetime.datetime.now().strftime("%Y%m%d%H%M%S")}_initial.json',
         )
+        with open(initial_task_filename, "w") as file:
+            json.dump(initial_task, file)
+
+        # Schedule the initial task
+        schedule_datetime = datetime.datetime.fromisoformat(
+            initial_task["schedule_datetime"]
+        )
+        self.schedule_in_task_scheduler(initial_task_filename, schedule_datetime)
+
+        self.temp_tasks = []  # Clear the temporary tasks
+        self.show_message()
+
+    def save_task_temporarily(self):
+        print("save_task_temporarily called")
+        task = self.create_task()
+        self.temp_tasks.append(task)
+        print(f"Added task to temp_tasks: {self.temp_tasks}")
+        print(f"len(self.temp_tasks) = {len(self.temp_tasks)}")
+        self.clear_input_fields()
+        if len(self.temp_tasks) == 1:
+            self.banner_label.setText(
+                "<b>Multi-Task Mode</b>" + "<br>" + "Nach dem ersten Task ausführen"
+            )
+        # Show the new top banner
+        self.show_confirmation_banner()
+        self.update_ui_elements()
+
+    def schedule_in_task_scheduler(self, task_filename, schedule_datetime):
+        import subprocess
+
+        date_str = schedule_datetime.strftime("%d/%m/%Y")
+        time_str = schedule_datetime.strftime("%H:%M")
+        command = f'SchTasks /Create /SC ONCE /TN "ButtonizerTask_{os.path.basename(task_filename)}" /TR "python {os.path.abspath(__file__).replace("bAUTOnizer3000.py", "exe_tasks.py")} {task_filename}" /ST {time_str} /SD {date_str} /F'
+        try:
+            subprocess.run(command, check=True, shell=True)
+        except subprocess.CalledProcessError as e:
+            print(f"Failed to schedule task: {e}")
 
     def schedule_task(self, marken_box, categories_box, articles_input, tab_name):
         task = self.create_task()
@@ -521,44 +540,138 @@
             )
             self.schedule_in_task_scheduler(task_filename, schedule_datetime)
 
+        # Show the confirmation banner
+        self.show_confirmation_banner("Task created")
+
         QMessageBox.information(self, "Success", "Task scheduled successfully!")
 
-    def schedule_in_task_scheduler(self, task_filename, schedule_datetime):
-        import subprocess
+    @QtCore.pyqtProperty(QColor)
+    def borderColor(self):
+        return self._borderColor
+
+    @borderColor.setter
+    def borderColor(self, color):
+        self._borderColor = color
+        self.update()  # Trigger a repaint
 
-        date_str = schedule_datetime.strftime("%d/%m/%Y")
-        time_str = schedule_datetime.strftime("%H:%M")
-        command = f'SchTasks /Create /SC ONCE /TN "ButtonizerTask_{os.path.basename(task_filename)}" /TR "python {os.path.abspath(__file__).replace("bAUTOnizer3000.py", "exe_tasks.py")} {task_filename}" /ST {time_str} /SD {date_str} /F'
-        try:
-            subprocess.run(command, check=True, shell=True)
-        except subprocess.CalledProcessError as e:
-            print(f"Failed to schedule task: {e}")
+    def paintEvent(self, event):
+        super().paintEvent(event)
+        painter = QPainter(self)
+        painter.setPen(QPen(self.borderColor, 15))  # Set pen with the current border color and width
+        painter.drawRect(self.rect())  # Draw the border around the window
+
+    def show_confirmation_banner(self, message="TASK ERSTELLT"):
+        # Create the animation for the border
+        self.border_animation = QPropertyAnimation(self, b"borderColor")
+        self.border_animation.setDuration(
+            500
+        )  # Duration of the animation in milliseconds
+        self.border_animation.setLoopCount(
+            1
+        )  # Number of times the animation should loop
+        self.border_animation.setStartValue(
+            QColor(60, 143, 64, 0)
+        )  # Start with transparent green
+        self.border_animation.setKeyValueAt(
+            0.5, QColor(60, 143, 64, 190)
+        )  # Fully opaque green at midpoint
+        self.border_animation.setEndValue(
+            QColor(60, 143, 64, 0)
+        )  # End with transparent green
+        self.border_animation.setEasingCurve(
+            QEasingCurve.Type.InOutQuad
+        )  # Smooth easing curve
+        self.border_animation.start()
+        self.top_banner_label.setStyleSheet("color: rgb(60, 143, 64);")
+        self.top_banner_label.setText(f"<b>{message}</b>")
+        self.top_banner_label.show()
+
+    def get_scheduled_time(self):
+        return datetime.datetime(
+            self.selected_date.year(),
+            self.selected_date.month(),
+            self.selected_date.day(),
+            self.selected_time.hour(),
+            self.selected_time.minute(),
+            self.selected_time.second(),
+        )
+
+    def show_datetime_fields(self):
+        self.display_label_title.show()
+        self.datetime_label.show()
+        for button in self.datetime_buttons:
+            if button not in self.layout.children():
+                self.layout.addWidget(button)
+
+    def show_message(self):
+        msg_box = QMessageBox(self)
+        msg_box.setWindowTitle("Geschafft")
+        msg_box.setText(
+            "Task erfolgreich geplant. \nDu siehst heute übrigens mal wieder super aus <3"
+        )
+        msg_box.setIcon(QMessageBox.Icon.Information)
+        msg_box.exec()
 
     def toggle_link_input(self, state, link_input_de, link_input_fr):
-        is_enabled = state == Qt.CheckState.Checked
-        link_input_de.setDisabled(not is_enabled)
-        link_input_fr.setDisabled(not is_enabled)
+        if state == Qt.CheckState.Checked:
+            link_input_de.setDisabled(False)
+            link_input_fr.setDisabled(False)
+        else:
+            link_input_de.setDisabled(True)
+            link_input_fr.setDisabled(True)
 
-    def center_on_screen(self):
-        qr = self.frameGeometry()
-        screen_geometry = QApplication.primaryScreen().availableGeometry()
-        cp = screen_geometry.center()
-        cp.setX(int(screen_geometry.width() * 3 / 4 - qr.width() / 4))
-        qr.moveCenter(cp)
-        self.move(qr.topLeft())
+    def toggle_multi_mode(self):
+        self.multi_mode = self.multi_task_radio.isChecked()
+        self.tab_widget.setStyleSheet(
+            "QTabWidget::pane { border: 2px solid #ffdd00; }"
+            if self.multi_mode
+            else "QTabWidget::pane { border: 2px solid #ffffff; }"
+        )
+        self.banner_label.setText(
+            "<b>Multi-Task Mode</b>" + "<br>" + "Startzeit und Datum Wählen"
+            if self.multi_mode
+            else ""
+        )
+        self.top_banner_label.hide()  # Hide the new top banner when switching modes
 
-    def update_subcategories(self, marken_box, categories_box):
-        current_brand = marken_box.currentText()
-        categories_box.clear()
-        if current_brand in self.category_data["Kamerasysteme + Objektive"]:
-            categories_box.addItems(
-                self.category_data["Kamerasysteme + Objektive"][current_brand].keys()
+        for tab_name in self.button_layouts:
+            self.update_buttons(tab_name)
+        self.update_ui_elements()
+
+    def update_buttons(self, tab_name):
+        button_layout = self.button_layouts[tab_name]
+        self.clear_layout(button_layout)
+        if self.multi_mode:
+            next_task_button = self.create_button(
+                "Next Task", self.save_task_temporarily
             )
-            categories_box.setCurrentIndex(0)
-            categories_box.setDisabled(False)
+            plan_tasks_button = self.create_button("Tasks Planen", self.save_all_tasks)
+            button_layout.addWidget(next_task_button)
+            button_layout.addWidget(plan_tasks_button)
         else:
-            categories_box.addItem("Keine Kategorien verfügbar")
-            categories_box.setDisabled(True)
+            submit_button = self.create_button(
+                "Bestätigen",
+                lambda: self.schedule_task(
+                    self.marken_combobox,
+                    self.categories_combobox,
+                    self.articles_input,
+                    tab_name,
+                ),
+            )
+            button_layout.addWidget(submit_button)
+
+    def update_datetime_label(self):
+        selected_date = self.selected_date.toString("dd/MM/yyyy")
+        selected_time = self.selected_time.toString("HH:mm:ss")
+        self.datetime_label.setText(f"{selected_date} \n{selected_time}")
+
+    def update_subcategories(self, marken_combobox, categories_combobox):
+        selected_marke = marken_combobox.currentText()
+        categories_combobox.clear()
+        if selected_marke in self.category_data["Kamerasysteme + Objektive"]:
+            categories_combobox.addItems(
+                self.category_data["Kamerasysteme + Objektive"][selected_marke].keys()
+            )
 
     def update_ui_elements(self):
         if self.multi_mode and len(self.temp_tasks) == 0:
@@ -568,60 +681,6 @@
         else:
             self.show_datetime_fields()
 
-    def debug_temporary_tasks(self):
-        print("Temporary tasks stored:")
-        for idx, task in enumerate(self.temp_tasks):
-            print(f"Task {idx + 1}: {task}")
-
-
-class TimePickerDialog(QDialog):
-    def __init__(self, parent=None):
-        super().__init__(parent)
-        self.setWindowTitle("Select Time")
-        self.layout = QVBoxLayout()
-        self.time_edit = QTimeEdit(self)
-        self.time_edit.setDisplayFormat("HH:mm:ss")
-        self.time_edit.setTime(QtCore.QTime.currentTime())
-        self.layout.addWidget(self.time_edit)
-
-        self.ok_button = QPushButton("OK", self)
-        self.ok_button.clicked.connect(self.confirm_time)
-        self.layout.addWidget(self.ok_button)
-
-        self.setLayout(self.layout)
-
-    def confirm_time(self):
-        self.selected_time = self.time_edit.time()
-        self.accept()
-
-    def get_time(self):
-        return self.selected_time
-
-
-class DatePickerDialog(QDialog):
-    def __init__(self, parent=None):
-        super().__init__(parent)
-        self.setWindowTitle("Select Date")
-        self.layout = QVBoxLayout()
-
-        self.calendar_widget = QCalendarWidget()
-        self.layout.addWidget(self.calendar_widget)
-
-        confirm_button = QPushButton("OK")
-        confirm_button.clicked.connect(self.confirm_date)
-        self.layout.addWidget(confirm_button)
-
-        self.selected_date = QDate.currentDate()
-
-        self.setLayout(self.layout)
-
-    def confirm_date(self):
-        self.selected_date = self.calendar_widget.selectedDate()
-        self.accept()
-
-    def get_date(self):
-        return self.selected_date
-
 
 if __name__ == "__main__":
     app = QApplication(sys.argv)
