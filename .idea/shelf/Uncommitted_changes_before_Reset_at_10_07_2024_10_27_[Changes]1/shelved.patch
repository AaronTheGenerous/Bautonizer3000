Index: bAUTOnizer3000.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\r\nimport os\r\nimport json\r\nimport datetime\r\nfrom PyQt6 import QtCore\r\nfrom PyQt6.QtWidgets import (\r\n    QApplication,\r\n    QWidget,\r\n    QVBoxLayout,\r\n    QHBoxLayout,\r\n    QComboBox,\r\n    QLineEdit,\r\n    QPushButton,\r\n    QLabel,\r\n    QMessageBox,\r\n    QTabWidget,\r\n    QDialog,\r\n    QTimeEdit,\r\n    QCalendarWidget,\r\n    QRadioButton,\r\n    QButtonGroup,\r\n    QCheckBox,\r\n)\r\nfrom PyQt6.QtCore import Qt, QDate, QTime, QEasingCurve, QPropertyAnimation\r\nfrom PyQt6.QtGui import QIcon, QFont, QColor, QPainter, QPen\r\n\r\n\r\nclass DatePickerDialog(QDialog):\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n        self.setWindowTitle(\"Datum wählen\")\r\n        self.calendar = QCalendarWidget(self)\r\n        self.calendar.setGridVisible(True)\r\n        layout = QVBoxLayout(self)\r\n        layout.addWidget(self.calendar)\r\n        buttons = QHBoxLayout()\r\n        ok_button = QPushButton(\"OK\", self)\r\n        ok_button.clicked.connect(self.accept)\r\n        cancel_button = QPushButton(\"Cancel\", self)\r\n        cancel_button.clicked.connect(self.reject)\r\n        buttons.addWidget(ok_button)\r\n        buttons.addWidget(cancel_button)\r\n        layout.addLayout(buttons)\r\n\r\n    def get_date(self):\r\n        return self.calendar.selectedDate()\r\n\r\n\r\nclass TimePickerDialog(QDialog):\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n        self.setWindowTitle(\"Uhrzeit wählen\")\r\n        self.time_edit = QTimeEdit(self)\r\n        self.time_edit.setDisplayFormat(\"HH:mm:ss\")\r\n        layout = QVBoxLayout(self)\r\n        layout.addWidget(self.time_edit)\r\n        buttons = QHBoxLayout()\r\n        ok_button = QPushButton(\"OK\", self)\r\n        ok_button.clicked.connect(self.accept)\r\n        cancel_button = QPushButton(\"Cancel\", self)\r\n        cancel_button.clicked.connect(self.reject)\r\n        buttons.addWidget(ok_button)\r\n        buttons.addWidget(cancel_button)\r\n        layout.addLayout(buttons)\r\n\r\n    def get_time(self):\r\n        return self.time_edit.time()\r\n\r\n\r\nclass App(QWidget):\r\n    tasks_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"tasks\")\r\n    last_task_end_time_file = os.path.join(tasks_directory, \"last_task_end_time.json\")\r\n    multi_mode = False  # Track if multi-mode is enabled\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.title = \"Buttonizer3000\"\r\n        self.left = 100\r\n        self.top = 100\r\n        self.window_width = 260\r\n        self.height = 850  # Increased height to accommodate the switch and banner\r\n        self.borderColor = QColor(255, 221, 0, 0)  # Initial border color (transparent yellow)\r\n\r\n        self.selected_date = QDate.currentDate()\r\n        self.selected_time = QTime.currentTime()\r\n\r\n        self.temp_tasks = []  # Temporary storage for tasks in multi-task mode\r\n\r\n        self.button_layouts = {}  # Temporary storage for each button layout\r\n\r\n        self.category_data = {\r\n            \"Kamerasysteme + Objektive\": {\r\n                \"Nikon\": {\r\n                    \"Nikon Z\": {},\r\n                    \"Nikkor Z-Mount Objektive\": {},\r\n                    \"Nikon DSLR\": {},\r\n                    \"Nikkor F-Mount Objektive\": {},\r\n                    \"Nikon Blitzgeräte\": {},\r\n                    \"Nikon Coolpix\": {},\r\n                    \"Nikon DSLR Zubehör\": {},\r\n                    \"Nikon Objektivzubehör\": {},\r\n                },\r\n                \"Sony\": {\r\n                    \"Sony E-Mount Kameras\": {},\r\n                    \"Sony E-Mount Objektive\": {},\r\n                    \"Sony E-Mount APS-C Kameras\": {},\r\n                    \"Sony E-Mount APS-C Objektive\": {},\r\n                    \"Sony E-Mount Zubehör\": {},\r\n                    \"Sony Blitzgeräte\": {},\r\n                    \"Sony Kompaktkameras\": {},\r\n                    \"Sony XPERIA Smartphones\": {},\r\n                    \"Sony A-Mount Kameras\": {},\r\n                    \"Sony A-Mount Objektive\": {},\r\n                    \"Sony A-Mount Zubehör\": {},\r\n                },\r\n                \"Phase One\": {\r\n                    \"Phase One IQ Backs\": {},\r\n                    \"Phase One XF Camera System\": {},\r\n                    \"Phase One XT Camera System\": {},\r\n                    \"CPO Phase One IQ Backs für Phase One XF\": {},\r\n                    \"CPO Phase One XF Kamerasysteme\": {},\r\n                    \"CPO Phase One IQ Backs für Hasselblad\": {},\r\n                    \"Phase One XF Kamerasysteme\": {},\r\n                    \"Phase One XT Kamera und Objektive\": {},\r\n                    \"Schneider Kreuznach Objektive (Blue Ring)\": {},\r\n                    \"CPO Schneider Kreuznach Objektive\": {},\r\n                    \"Capture One\": {},\r\n                },\r\n                \"Cambo\": {\r\n                    \"Cambo Wide RS\": {},\r\n                    \"Cambo ACTUS\": {},\r\n                    \"Cambo Zubehör zu Phase One XT\": {},\r\n                    \"Cambo Adapter\": {},\r\n                    \"Cambo ACTUS DB\": {},\r\n                    \"Cambo ACTUS-XL\": {},\r\n                },\r\n                \"Leica\": {\r\n                    \"Leica M & Objektive\": {},\r\n                    \"Leica Q\": {},\r\n                    \"Leica SL & Objektive\": {},\r\n                    \"Leica S & Objektive\": {},\r\n                    \"Leica TL / CL & Objektive\": {},\r\n                    \"Leica V\": {},\r\n                    \"Leica X\": {},\r\n                    \"Leica SOFORT\": {},\r\n                },\r\n            }\r\n        }\r\n\r\n        self.initUI()\r\n\r\n    def initUI(self):\r\n        self.setWindowTitle(self.title)\r\n        self.setGeometry(self.left, self.top, self.window_width, self.height)\r\n        self.setFixedSize(self.window_width, self.height)\r\n        self.setWindowIcon(QIcon(r\"C:\\path\\to\\icon.ico\"))\r\n\r\n        self.main_layout = QVBoxLayout()\r\n\r\n        # Create the switch for Single-Task Mode and Multi-Task Mode\r\n        self.create_mode_switch(self.main_layout)\r\n\r\n        # New banner label at the very top\r\n        self.top_banner_label = self.create_label(\"\", 10, Qt.AlignmentFlag.AlignCenter)\r\n        self.main_layout.addWidget(self.top_banner_label)\r\n\r\n        self.banner_label = self.create_label(\"\", 10, Qt.AlignmentFlag.AlignCenter)\r\n        self.main_layout.addWidget(self.banner_label)\r\n\r\n        self.tab_widget = QTabWidget()\r\n        self.tab_widget.setStyleSheet(\"QTabWidget::pane { border: 2px solid #ffffff; }\")\r\n        self.tab_widget.addTab(\r\n            self.create_tab(\"Hinzufügen\", self.schedule_task), \"Hinzufügen\"\r\n        )\r\n        self.tab_widget.addTab(\r\n            self.create_tab(\"Entfernen\", self.schedule_task), \"Entfernen\"\r\n        )\r\n        self.main_layout.addWidget(self.tab_widget)\r\n\r\n        self.display_label_title = self.create_label(\r\n            \"<b>Geplantes Datum und Uhrzeit</b>\", 10, Qt.AlignmentFlag.AlignCenter, True\r\n        )\r\n        self.main_layout.addWidget(self.display_label_title)\r\n\r\n        self.datetime_label = self.create_label(\r\n            \"\", 15, Qt.AlignmentFlag.AlignCenter, True\r\n        )\r\n        self.update_datetime_label()\r\n        self.main_layout.addWidget(self.datetime_label)\r\n\r\n        self.setLayout(self.main_layout)\r\n        self.center_on_screen()\r\n        self.show()\r\n\r\n    def add_datetime_fields(self, layout):\r\n        self.dateTime_title_label = QLabel(\"<b>Datum & Uhrzeit planen</b>\", self)\r\n        self.dateTime_title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)\r\n        self.dateTime_title_label.setStyleSheet(\r\n            \"\"\"\r\n            QLabel{\r\n                font-weight: bold;\r\n            }\r\n        \"\"\"\r\n        )\r\n        layout.addWidget(self.dateTime_title_label)\r\n\r\n        buttons = [\r\n            (\"Datum wählen\", self.open_date_picker),\r\n            (\"Uhrzeit wählen\", self.open_time_picker),\r\n        ]\r\n        self.datetime_buttons = []\r\n        for text, handler in buttons:\r\n            button = QPushButton(text, self)\r\n            button.clicked.connect(handler)\r\n            layout.addWidget(button)\r\n            self.datetime_buttons.append(button)\r\n\r\n    def add_image_and_link_fields(self, layout):\r\n        fields = [\r\n            (\"Bild 1 URL (Deutsch)\", \"img1_input\"),\r\n            (\"Bild 2 URL (Französisch)\", \"img2_input\"),\r\n            (\"Bild Höhe\", \"height_input\"),\r\n            (\"Bildbreite\", \"width_input\"),\r\n        ]\r\n        for label_text, attr_name in fields:\r\n            setattr(\r\n                self, attr_name, self.create_line_edit_with_label(label_text, layout)\r\n            )\r\n            layout.addWidget(getattr(self, attr_name))\r\n\r\n        self.link_checkbox = QCheckBox(\"Link hinzufügen?\", self)\r\n        layout.addWidget(self.link_checkbox)\r\n\r\n        self.link_input_de = self.create_line_edit_with_label(\"Link (Deutsch)\", layout)\r\n        self.link_input_de.setDisabled(True)\r\n        layout.addWidget(self.link_input_de)\r\n\r\n        self.link_input_fr = self.create_line_edit_with_label(\r\n            \"Link (Französisch)\", layout\r\n        )\r\n        self.link_input_fr.setDisabled(True)\r\n        layout.addWidget(self.link_input_fr)\r\n\r\n        self.link_checkbox.stateChanged.connect(\r\n            lambda state: self.toggle_link_input(\r\n                state, self.link_input_de, self.link_input_fr\r\n            )\r\n        )\r\n\r\n    def center_on_screen(self):\r\n        resolution = QApplication.primaryScreen().geometry()\r\n        x = (resolution.width() - self.window_width) // 2\r\n        y = (resolution.height() - self.height) // 2\r\n        self.move(x, y)\r\n\r\n    def clear_input_fields(self):\r\n        self.marken_combobox.setCurrentIndex(0)\r\n        self.categories_combobox.setCurrentIndex(0)\r\n        self.articles_input.clear()\r\n        if self.current_tab_name == \"Hinzufügen\":\r\n            self.img1_input.clear()\r\n            self.img2_input.clear()\r\n            self.width_input.clear()\r\n            self.height_input.clear()\r\n            self.link_checkbox.setChecked(False)\r\n            self.link_input_de.clear()\r\n            self.link_input_fr.clear()\r\n\r\n    def clear_layout(self, layout):\r\n        while layout.count():\r\n            child = layout.takeAt(0)\r\n            if child.widget():\r\n                child.widget().deleteLater()\r\n\r\n    def create_button(self, text, click_handler):\r\n        button = QPushButton(text, self)\r\n        button.clicked.connect(click_handler)\r\n        return button\r\n\r\n    def create_label(self, text, font_size, alignment, with_border=False):\r\n        label = QLabel(text, self)\r\n        font = QFont()\r\n        font.setPointSize(font_size)\r\n        label.setFont(font)\r\n        label.setAlignment(alignment)\r\n        if with_border:\r\n            label.setStyleSheet(\"border: 2px solid #ffdd00;\")\r\n        return label\r\n\r\n    def create_label_and_combobox(self, label_text, items):\r\n        label = QLabel(label_text, self)\r\n        combobox = QComboBox(self)\r\n        combobox.addItems(items)\r\n        return label, combobox\r\n\r\n    def create_line_edit_with_label(self, label_text, layout):\r\n        label = QLabel(label_text, self)\r\n        layout.addWidget(label)\r\n        return QLineEdit(self)\r\n\r\n    def create_mode_switch(self, layout):\r\n        self.single_task_radio = QRadioButton(\"Single-Task Mode\")\r\n        self.multi_task_radio = QRadioButton(\"Multi-Task Mode\")\r\n\r\n        self.button_group = QButtonGroup(self)\r\n        self.button_group.addButton(self.single_task_radio)\r\n        self.button_group.addButton(self.multi_task_radio)\r\n        self.single_task_radio.setChecked(True)  # Default to Single-Task Mode\r\n\r\n        self.single_task_radio.toggled.connect(self.toggle_multi_mode)\r\n        self.multi_task_radio.toggled.connect(self.toggle_multi_mode)\r\n\r\n        switch_layout = QHBoxLayout()\r\n        switch_layout.addWidget(self.single_task_radio)\r\n        switch_layout.addWidget(self.multi_task_radio)\r\n        layout.addLayout(switch_layout)\r\n\r\n    def create_tab(self, tab_name, submit_action):\r\n        tab = QWidget()\r\n        layout = QVBoxLayout()\r\n\r\n        self.current_tab_name = tab_name\r\n        marken_label, marken_combobox = self.create_label_and_combobox(\r\n            \"Marke\", self.category_data[\"Kamerasysteme + Objektive\"].keys()\r\n        )\r\n        layout.addWidget(marken_label)\r\n        layout.addWidget(marken_combobox)\r\n        self.marken_combobox = marken_combobox\r\n\r\n        categories_label, categories_combobox = self.create_label_and_combobox(\r\n            \"Kategorie\", []\r\n        )\r\n        layout.addWidget(categories_label)\r\n        layout.addWidget(categories_combobox)\r\n        self.categories_combobox = categories_combobox\r\n\r\n        layout.addStretch()\r\n        articles_input = self.create_line_edit_with_label(\r\n            \"Artikelnummern (getrennt mit Kommas)\", layout\r\n        )\r\n        layout.addWidget(articles_input)\r\n        self.articles_input = articles_input\r\n\r\n        if tab_name == \"Hinzufügen\":\r\n            self.add_image_and_link_fields(layout)\r\n\r\n        self.add_datetime_fields(layout)\r\n\r\n        button_layout = QVBoxLayout()\r\n        self.button_layouts[tab_name] = button_layout  # Store the button layout\r\n        self.update_buttons(tab_name)\r\n        layout.addLayout(button_layout)\r\n\r\n        self.update_subcategories(marken_combobox, categories_combobox)\r\n        marken_combobox.currentTextChanged.connect(\r\n            lambda: self.update_subcategories(marken_combobox, categories_combobox)\r\n        )\r\n\r\n        tab.setLayout(layout)\r\n\r\n        return tab\r\n\r\n    def create_task(self):\r\n        task_type = (\r\n            \"process_articles\"\r\n            if self.current_tab_name == \"Hinzufügen\"\r\n            else \"remove_articles_images\"\r\n        )\r\n\r\n        task = {\r\n            \"task_type\": task_type,\r\n            \"schedule_datetime\": self.get_scheduled_time().isoformat(),\r\n            \"data\": {\r\n                \"marke\": self.marken_combobox.currentText(),\r\n                \"kategorie\": self.categories_combobox.currentText(),\r\n                \"article_numbers\": self.articles_input.text(),\r\n                \"img1_url\": (\r\n                    self.img1_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"img2_url\": (\r\n                    self.img2_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"width\": (\r\n                    self.width_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"height\": (\r\n                    self.height_input.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_checkbox\": (\r\n                    self.link_checkbox.isChecked()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_input_de\": (\r\n                    self.link_input_de.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n                \"link_input_fr\": (\r\n                    self.link_input_fr.text()\r\n                    if self.current_tab_name == \"Hinzufügen\"\r\n                    else None\r\n                ),\r\n            },\r\n            \"follow_up\": self.multi_mode,\r\n        }\r\n        return task\r\n\r\n    def eventFilter(self, obj, event):\r\n        if event.type() == QtCore.QEvent.Type.KeyPress and event.key() in [\r\n            Qt.Key.Key_Enter,\r\n            Qt.Key.Key_Return,\r\n        ]:\r\n            current_tab_index = self.tab_widget.currentIndex()\r\n            if current_tab_index == 0:\r\n                self.submit_button.click()\r\n            elif current_tab_index == 1:\r\n                self.submit_button2.click()\r\n            return True\r\n        return super().eventFilter(obj, event)\r\n\r\n    def hide_datetime_fields(self):\r\n        self.dateTime_title_label.hide()\r\n        for button in self.datetime_buttons:\r\n            button.hide()\r\n\r\n    def open_date_picker(self):\r\n        dialog = DatePickerDialog(self)\r\n        if dialog.exec():\r\n            self.selected_date = dialog.get_date()\r\n            self.update_datetime_label()\r\n\r\n    def open_time_picker(self):\r\n        dialog = TimePickerDialog(self)\r\n        if dialog.exec():\r\n            self.selected_time = dialog.get_time()\r\n            self.update_datetime_label()\r\n\r\n    def save_all_tasks(self):\r\n        task_directory = self.tasks_directory\r\n        os.makedirs(task_directory, exist_ok=True)\r\n\r\n        initial_task = self.temp_tasks[0]\r\n        initial_task[\"subsequent_tasks\"] = []\r\n\r\n        for idx, task in enumerate(self.temp_tasks):\r\n            task_filename = os.path.join(\r\n                task_directory,\r\n                f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}_{idx}.json',\r\n            )\r\n            with open(task_filename, \"w\") as file:\r\n                json.dump(task, file)\r\n            if idx > 0:\r\n                initial_task[\"subsequent_tasks\"].append(task_filename)\r\n\r\n        initial_task_filename = os.path.join(\r\n            task_directory,\r\n            f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}_initial.json',\r\n        )\r\n        with open(initial_task_filename, \"w\") as file:\r\n            json.dump(initial_task, file)\r\n\r\n        # Schedule the initial task\r\n        schedule_datetime = datetime.datetime.fromisoformat(\r\n            initial_task[\"schedule_datetime\"]\r\n        )\r\n        self.schedule_in_task_scheduler(initial_task_filename, schedule_datetime)\r\n\r\n        self.temp_tasks = []  # Clear the temporary tasks\r\n        self.show_message()\r\n\r\n    def save_task_temporarily(self):\r\n        task = self.create_task()\r\n        self.temp_tasks.append(task)\r\n        self.clear_input_fields()\r\n        if len(self.temp_tasks) == 1:\r\n            self.banner_label.setText(\r\n                \"<b>Multi-Task Mode</b>\" + \"<br>\" + \"Nach dem ersten Task ausführen\"\r\n            )\r\n            self.hide_datetime_fields()\r\n        # Show the new top banner\r\n        self.show_confirmation_banner()\r\n\r\n    def schedule_in_task_scheduler(self, task_filename, schedule_datetime):\r\n        import subprocess\r\n\r\n        date_str = schedule_datetime.strftime(\"%d/%m/%Y\")\r\n        time_str = schedule_datetime.strftime(\"%H:%M\")\r\n        command = f'SchTasks /Create /SC ONCE /TN \"ButtonizerTask_{os.path.basename(task_filename)}\" /TR \"python {os.path.abspath(__file__).replace(\"bAUTOnizer3000.py\", \"exe_tasks.py\")} {task_filename}\" /ST {time_str} /SD {date_str} /F'\r\n        try:\r\n            subprocess.run(command, check=True, shell=True)\r\n        except subprocess.CalledProcessError as e:\r\n            print(f\"Failed to schedule task: {e}\")\r\n\r\n    def schedule_task(self, marken_box, categories_box, articles_input, tab_name):\r\n        task = self.create_task()\r\n\r\n        task_filename = os.path.join(\r\n            self.tasks_directory,\r\n            f'task_{datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")}.json',\r\n        )\r\n\r\n        os.makedirs(self.tasks_directory, exist_ok=True)\r\n\r\n        with open(task_filename, \"w\") as file:\r\n            json.dump(task, file)\r\n\r\n        if not self.multi_mode:\r\n            # Convert schedule_datetime from string to datetime object\r\n            schedule_datetime = datetime.datetime.fromisoformat(\r\n                task[\"schedule_datetime\"]\r\n            )\r\n            self.schedule_in_task_scheduler(task_filename, schedule_datetime)\r\n\r\n        # Show the confirmation banner\r\n        self.show_confirmation_banner(\"Task created\")\r\n\r\n        QMessageBox.information(self, \"Success\", \"Task scheduled successfully!\")\r\n\r\n    @QtCore.pyqtProperty(QColor)\r\n    def borderColor(self):\r\n        return self._borderColor\r\n\r\n    @borderColor.setter\r\n    def borderColor(self, color):\r\n        self._borderColor = color\r\n        self.update()  # Trigger a repaint\r\n\r\n    def paintEvent(self, event):\r\n        super().paintEvent(event)\r\n        painter = QPainter(self)\r\n        painter.setPen(QPen(self.borderColor, 15))  # Set pen with the current border color and width\r\n        painter.drawRect(self.rect())  # Draw the border around the window\r\n\r\n    def show_confirmation_banner(self, message=\"Task created\"):\r\n        # Create the animation for the border\r\n        self.border_animation = QPropertyAnimation(self, b\"borderColor\")\r\n        self.border_animation.setDuration(\r\n            500\r\n        )  # Duration of the animation in milliseconds\r\n        self.border_animation.setLoopCount(\r\n            1\r\n        )  # Number of times the animation should loop\r\n        self.border_animation.setStartValue(\r\n            QColor(60, 143, 64, 0)\r\n        )  # Start with transparent green\r\n        self.border_animation.setKeyValueAt(\r\n            0.5, QColor(60, 143, 64, 190)\r\n        )  # Fully opaque green at midpoint\r\n        self.border_animation.setEndValue(\r\n            QColor(60, 143, 64, 0)\r\n        )  # End with transparent green\r\n        self.border_animation.setEasingCurve(\r\n            QEasingCurve.Type.InOutQuad\r\n        )  # Smooth easing curve\r\n        self.border_animation.start()\r\n        self.top_banner_label.setText(message)\r\n        self.top_banner_label.show()\r\n\r\n    def get_scheduled_time(self):\r\n        return datetime.datetime(\r\n            self.selected_date.year(),\r\n            self.selected_date.month(),\r\n            self.selected_date.day(),\r\n            self.selected_time.hour(),\r\n            self.selected_time.minute(),\r\n            self.selected_time.second(),\r\n        )\r\n\r\n    def show_datetime_fields(self):\r\n        self.dateTime_title_label.show()\r\n        for button in self.datetime_buttons:\r\n            button.show()\r\n        self.display_label_title.show()\r\n        self.datetime_label.show()\r\n\r\n    def show_message(self):\r\n        msg_box = QMessageBox(self)\r\n        msg_box.setWindowTitle(\"Geschafft\")\r\n        msg_box.setText(\r\n            \"Task erfolgreich geplant. \\nDu siehst heute übrigens mal wieder super aus <3\"\r\n        )\r\n        msg_box.setIcon(QMessageBox.Icon.Information)\r\n        msg_box.exec()\r\n\r\n    def toggle_link_input(self, state, link_input_de, link_input_fr):\r\n        if state == Qt.CheckState.Checked:\r\n            link_input_de.setDisabled(False)\r\n            link_input_fr.setDisabled(False)\r\n        else:\r\n            link_input_de.setDisabled(True)\r\n            link_input_fr.setDisabled(True)\r\n\r\n    def toggle_multi_mode(self):\r\n        self.multi_mode = self.multi_task_radio.isChecked()\r\n        self.tab_widget.setStyleSheet(\r\n            \"QTabWidget::pane { border: 2px solid #ffdd00; }\"\r\n            if self.multi_mode\r\n            else \"QTabWidget::pane { border: 2px solid #ffffff; }\"\r\n        )\r\n        self.banner_label.setText(\r\n            \"<b>Multi-Task Mode</b>\" + \"<br>\" + \"Startzeit und Datum Wählen\"\r\n            if self.multi_mode\r\n            else \"\"\r\n        )\r\n        self.top_banner_label.hide()  # Hide the new top banner when switching modes\r\n\r\n        for tab_name in self.button_layouts:\r\n            self.update_buttons(tab_name)\r\n        self.update_ui_elements()\r\n\r\n    def update_buttons(self, tab_name):\r\n        button_layout = self.button_layouts[tab_name]\r\n        self.clear_layout(button_layout)\r\n        if self.multi_mode:\r\n            next_task_button = self.create_button(\r\n                \"Next Task\", self.save_task_temporarily\r\n            )\r\n            plan_tasks_button = self.create_button(\"Tasks Planen\", self.save_all_tasks)\r\n            button_layout.addWidget(next_task_button)\r\n            button_layout.addWidget(plan_tasks_button)\r\n        else:\r\n            submit_button = self.create_button(\r\n                \"Bestätigen\",\r\n                lambda: self.schedule_task(\r\n                    self.marken_combobox,\r\n                    self.categories_combobox,\r\n                    self.articles_input,\r\n                    tab_name,\r\n                ),\r\n            )\r\n            button_layout.addWidget(submit_button)\r\n\r\n    def update_datetime_label(self):\r\n        selected_date = self.selected_date.toString(\"dd/MM/yyyy\")\r\n        selected_time = self.selected_time.toString(\"HH:mm:ss\")\r\n        self.datetime_label.setText(f\"{selected_date} \\n{selected_time}\")\r\n\r\n    def update_subcategories(self, marken_combobox, categories_combobox):\r\n        selected_marke = marken_combobox.currentText()\r\n        categories_combobox.clear()\r\n        if selected_marke in self.category_data[\"Kamerasysteme + Objektive\"]:\r\n            categories_combobox.addItems(\r\n                self.category_data[\"Kamerasysteme + Objektive\"][selected_marke].keys()\r\n            )\r\n\r\n    def update_ui_elements(self):\r\n        if self.multi_mode and len(self.temp_tasks) == 0:\r\n            self.show_datetime_fields()\r\n        elif self.multi_mode and len(self.temp_tasks) > 0:\r\n            self.hide_datetime_fields()\r\n        else:\r\n            self.show_datetime_fields()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    app = QApplication(sys.argv)\r\n    ex = App()\r\n    sys.exit(app.exec())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bAUTOnizer3000.py b/bAUTOnizer3000.py
--- a/bAUTOnizer3000.py	
+++ b/bAUTOnizer3000.py	
@@ -28,19 +28,30 @@
 class DatePickerDialog(QDialog):
     def __init__(self, parent=None):
         super().__init__(parent)
+        self.layout = None
+        self.calendar = None
         self.setWindowTitle("Datum wählen")
+        self.create_calendar_widget()
+        self.create_buttons()
+
+    def create_calendar_widget(self):
         self.calendar = QCalendarWidget(self)
         self.calendar.setGridVisible(True)
-        layout = QVBoxLayout(self)
-        layout.addWidget(self.calendar)
+        self.layout = QVBoxLayout(self)
+        self.layout.addWidget(self.calendar)
+
+    def create_buttons(self):
         buttons = QHBoxLayout()
-        ok_button = QPushButton("OK", self)
-        ok_button.clicked.connect(self.accept)
-        cancel_button = QPushButton("Cancel", self)
-        cancel_button.clicked.connect(self.reject)
+        ok_button = self.create_button("OK", self.accept)
+        cancel_button = self.create_button("Abbrechen", self.reject)
         buttons.addWidget(ok_button)
         buttons.addWidget(cancel_button)
-        layout.addLayout(buttons)
+        self.layout.addLayout(buttons)
+
+    def create_button(self, text, handler):
+        button = QPushButton(text, self)
+        button.clicked.connect(handler)
+        return button
 
     def get_date(self):
         return self.calendar.selectedDate()
@@ -86,7 +97,42 @@
 
         self.temp_tasks = []  # Temporary storage for tasks in multi-task mode
 
-        self.button_layouts = {}  # Temporary storage for each button layout
+        self.button_layouts = {}
+
+        self.buttons = {
+            'single': {
+                'hinzufügen': {'buttons': QPushButton('Bestätigen'),
+                               'dt_buttons': [QPushButton('Datum wählen'), QPushButton('Uhrzeit wählen')]},
+                'entfernen': {'buttons': QPushButton('Bestätigen'),
+                               'dt_buttons': [QPushButton('Datum wählen'), QPushButton('Uhrzeit wählen')]},
+            },
+            'multi': {
+                'hinzufügen': {'buttons': [QPushButton('Next Task'), QPushButton('Tasks Planen')],
+                               'dt_buttons': [QPushButton('Datum wählen'), QPushButton('Uhrzeit wählen')]},
+                'entfernen': {'buttons': [QPushButton('Next Task'), QPushButton('Tasks Planen')],
+                              'dt_buttons': [QPushButton('Datum wählen'), QPushButton('Uhrzeit wählen')]}
+            }
+        }
+
+        self.buttons['single']['hinzufügen']['buttons'].clicked.connect(self.schedule_task)
+        self.buttons['single']['hinzufügen']['dt_buttons'][0].clicked.connect(self.open_date_picker)
+        self.buttons['single']['hinzufügen']['dt_buttons'][1].clicked.connect(self.open_time_picker)
+
+        self.buttons['single']['entfernen']['buttons'].clicked.connect(self.schedule_task)
+        self.buttons['single']['entfernen']['dt_buttons'][0].clicked.connect(self.open_date_picker)
+        self.buttons['single']['entfernen']['dt_buttons'][1].clicked.connect(self.open_time_picker)
+
+        self.buttons['multi']['hinzufügen']['buttons'][0].clicked.connect(self.save_task_temporarily)
+        self.buttons['multi']['hinzufügen']['buttons'][1].clicked.connect(self.save_task_temporarily)
+        self.buttons['multi']['hinzufügen']['buttons'][1].clicked.connect(self.save_all_tasks)
+        self.buttons['multi']['hinzufügen']['dt_buttons'][0].clicked.connect(self.open_date_picker)
+        self.buttons['multi']['hinzufügen']['dt_buttons'][1].clicked.connect(self.open_time_picker)
+
+        self.buttons['multi']['entfernen']['buttons'][0].clicked.connect(self.save_task_temporarily)
+        self.buttons['multi']['entfernen']['buttons'][1].clicked.connect(self.save_task_temporarily)
+        self.buttons['multi']['entfernen']['buttons'][1].clicked.connect(self.save_all_tasks)
+        self.buttons['multi']['entfernen']['dt_buttons'][0].clicked.connect(self.open_date_picker)
+        self.buttons['multi']['entfernen']['dt_buttons'][1].clicked.connect(self.open_time_picker)
 
         self.category_data = {
             "Kamerasysteme + Objektive": {
@@ -175,6 +221,7 @@
         self.tab_widget.addTab(
             self.create_tab("Entfernen", self.schedule_task), "Entfernen"
         )
+        self.tab_widget.currentChanged.connect(self.on_tab_changed)
         self.main_layout.addWidget(self.tab_widget)
 
         self.display_label_title = self.create_label(
@@ -212,9 +259,11 @@
         for text, handler in buttons:
             button = QPushButton(text, self)
             button.clicked.connect(handler)
-            layout.addWidget(button)
             self.datetime_buttons.append(button)
 
+        for button in self.datetime_buttons:
+            layout.addWidget(button)
+
     def add_image_and_link_fields(self, layout):
         fields = [
             ("Bild 1 URL (Deutsch)", "img1_input"),
@@ -361,6 +410,7 @@
         return tab
 
     def create_task(self):
+        print("create_task called")
         task_type = (
             "process_articles"
             if self.current_tab_name == "Hinzufügen"
@@ -428,10 +478,23 @@
         return super().eventFilter(obj, event)
 
     def hide_datetime_fields(self):
-        self.dateTime_title_label.hide()
+        self.display_label_title.hide()
+        self.datetime_label.hide()
         for button in self.datetime_buttons:
-            button.hide()
+            if button not in [self.layout().itemAt(i).widget() for i in range(self.layout().count())]:
+                self.layout().removeWidget(button)
+                button.hide()
 
+    def on_tab_changed(self, index):
+        self.current_tab_name = 'Hinzufügen' if index == 0 else 'Entfernen'
+        self.tab_widget.removeTab(index)
+        self.tab_widget.insertTab(
+            index,
+            self.create_tab(self.current_tab_name, self.schedule_task),
+            self.current_tab_name
+        )
+        self.tab_widget.setCurrentIndex(index)
+
     def open_date_picker(self):
         dialog = DatePickerDialog(self)
         if dialog.exec():
@@ -477,17 +540,25 @@
         self.temp_tasks = []  # Clear the temporary tasks
         self.show_message()
 
+    def create_hash(self, task):
+        import hashlib
+        task_string = json.dumps(task)
+        return hashlib.md5(task_string.encode()).hexdigest()
+
     def save_task_temporarily(self):
+        print("save_task_temporarily called")
         task = self.create_task()
         self.temp_tasks.append(task)
+        print(f"Added task to temp_tasks: {self.temp_tasks}")
+        print(f"len(self.temp_tasks) = {len(self.temp_tasks)}")
         self.clear_input_fields()
         if len(self.temp_tasks) == 1:
             self.banner_label.setText(
                 "<b>Multi-Task Mode</b>" + "<br>" + "Nach dem ersten Task ausführen"
             )
-            self.hide_datetime_fields()
         # Show the new top banner
         self.show_confirmation_banner()
+        self.update_ui_elements()
 
     def schedule_in_task_scheduler(self, task_filename, schedule_datetime):
         import subprocess
@@ -540,7 +611,7 @@
         painter.setPen(QPen(self.borderColor, 15))  # Set pen with the current border color and width
         painter.drawRect(self.rect())  # Draw the border around the window
 
-    def show_confirmation_banner(self, message="Task created"):
+    def show_confirmation_banner(self, message="TASK ERSTELLT"):
         # Create the animation for the border
         self.border_animation = QPropertyAnimation(self, b"borderColor")
         self.border_animation.setDuration(
@@ -562,7 +633,8 @@
             QEasingCurve.Type.InOutQuad
         )  # Smooth easing curve
         self.border_animation.start()
-        self.top_banner_label.setText(message)
+        self.top_banner_label.setStyleSheet("color: rgb(60, 143, 64);")
+        self.top_banner_label.setText(f"<b>{message}</b>")
         self.top_banner_label.show()
 
     def get_scheduled_time(self):
@@ -576,11 +648,11 @@
         )
 
     def show_datetime_fields(self):
-        self.dateTime_title_label.show()
-        for button in self.datetime_buttons:
-            button.show()
         self.display_label_title.show()
         self.datetime_label.show()
+        for button in self.datetime_buttons:
+            if button not in [self.layout().itemAt(i).widget() for i in range(self.layout().count())]:
+                self.layout().addWidget(button)
 
     def show_message(self):
         msg_box = QMessageBox(self)
@@ -613,31 +685,39 @@
         )
         self.top_banner_label.hide()  # Hide the new top banner when switching modes
 
-        for tab_name in self.button_layouts:
-            self.update_buttons(tab_name)
-        self.update_ui_elements()
+        # Call update_buttons function to update the buttons instead of re-writing the same logic again
+        self.update_buttons(self.current_tab_name)
 
     def update_buttons(self, tab_name):
         button_layout = self.button_layouts[tab_name]
+
+        # Clear the current layout
         self.clear_layout(button_layout)
-        if self.multi_mode:
-            next_task_button = self.create_button(
-                "Next Task", self.save_task_temporarily
-            )
-            plan_tasks_button = self.create_button("Tasks Planen", self.save_all_tasks)
-            button_layout.addWidget(next_task_button)
-            button_layout.addWidget(plan_tasks_button)
+
+        # Create a list for the new buttons
+        new_buttons = []
+
+        if self.multi_mode and tab_name == "Hinzufügen":
+            for sound_file in self.sound_files:
+                button = QPushButton(sound_file.name)
+                button.clicked.connect(lambda _, file=sound_file: self.schedule_task(file))
+                new_buttons.append(button)
+            self.buttons[tab_name] = new_buttons  # store the new buttons
+        elif self.multi_mode and tab_name == "Entfernen":
+            cur_buttons = self.buttons["Hinzufügen"]
+            for button in cur_buttons:
+                if not button.isVisible():
+                    new_button = QPushButton(button.text())
+                    new_button.clicked.connect(lambda: self.schedule_task(None, new_button.text(), tab_name=tab_name))
+                    new_buttons.append(new_button)
+            self.buttons[tab_name] = new_buttons
         else:
-            submit_button = self.create_button(
-                "Bestätigen",
-                lambda: self.schedule_task(
-                    self.marken_combobox,
-                    self.categories_combobox,
-                    self.articles_input,
-                    tab_name,
-                ),
-            )
-            button_layout.addWidget(submit_button)
+            # existing code unchanged
+            pass
+
+        # Add the new buttons to the layout
+        for button in self.buttons[tab_name]:
+            button_layout.addWidget(button)
 
     def update_datetime_label(self):
         selected_date = self.selected_date.toString("dd/MM/yyyy")
